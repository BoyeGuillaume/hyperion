//! Runtime primitives for loading Hyperion plugins from shared libraries.
//!
//! This module ties together the metadata recorded in `HyperionMetaInfo`, the
//! exported symbols generated by `define_plugin_loader!` and
//! `define_plugin_compatibility!`, and the runtime abstractions (`PluginExt`,
//! `PluginExtStatic`, `PluginExtWrapper`) that host applications use after the
//! library is loaded. See `docs/PluginSystem.md` for the broader integration
//! guide.

use std::{
    collections::BTreeMap,
    ops::{Deref, DerefMut},
    path::{Path, PathBuf},
    sync::{Arc, Weak},
};

use libloading::Library;
use parking_lot::{Mutex, RwLock};
use semver::{Version, VersionReq};
use uuid::Uuid;

use crate::{
    base::{InstanceContext, meta::HyperionMetaInfo},
    magic::{EXT_COMPATIBILITY_CHECK_FN_NAME, EXT_LOADER_FN_NAME},
    utils::{
        conf::ExtList,
        error::{HyError, HyResult},
    },
};

/// Function signature that plugin crates must expose under
/// [`EXT_LOADER_FN_NAME`]. The host passes the UUID declared in the metadata and
/// expects back an instantiated [`PluginExt`].
pub type ExtLoaderFn = unsafe fn(Uuid, &mut ExtList) -> HyResult<Box<dyn PluginExt>>;

/// Function signature that plugin crates must expose under
/// [`EXT_COMPATIBILITY_CHECK_FN_NAME`]. The function returns the version
/// requirement describing which Hyperion hosts the plugin supports.
pub type ExtCompatibilityCheckFn = unsafe fn() -> VersionReq;

/// Generates the fixed-name compatibility function that Hyperion probes for
/// after loading the shared object.
///
/// The macro parses the provided string literal as a `semver::VersionReq` and
/// emits `__hyext_fn_compatibility_check`, which is later matched by
/// [`load_plugin_by_name`]. Failures while parsing the literal panic at compile
/// time, so malformed requirements are caught early.
#[macro_export]
macro_rules! define_plugin_compatibility {
    (
        $compat:literal
    ) => {
        #[unsafe(no_mangle)]
        pub fn __hyext_fn_compatibility_check() -> semver::VersionReq {
            semver::VersionReq::parse($compat).unwrap()
        }
    };
}

/// Generates the entry-point loader function used to instantiate plugins.
///
/// The macro accepts one or more concrete types implementing
/// [`PluginExtStatic`]. At runtime Hyperion passes the UUID read from metadata
/// and expects the loader to return the matching plugin instance. Unknown UUIDs
/// translate into [`HyError::ExtensionNotFound`].
#[macro_export]
macro_rules! define_plugin_loader {
    (
        $( $plugin_ty:ty ),+
        $(,)?
    ) => {
        #[unsafe(no_mangle)]
        pub unsafe fn __hyext_fn_loader(uuid: uuid::Uuid, ext: &mut hycore::utils::conf::ExtList) -> hycore::utils::error::HyResult<Box<dyn hycore::base::ext::PluginExt>> {
            match uuid {
                $(
                    <$plugin_ty as hycore::base::ext::PluginExtStatic>::UUID => {
                        let plugin = <$plugin_ty as hycore::base::ext::PluginExtStatic>::new(ext);
                        assert_eq!(plugin.uuid(), <$plugin_ty as hycore::base::ext::PluginExtStatic>::UUID, "Plugin UUID does not match the expected UUID");
                        return Ok(Box::new(plugin));
                    },
                )+
                _ => {
                    Err(hycore::utils::error::HyError::ExtensionNotFound(uuid.to_string()))
                },
            }
        }
    };
}

/// Runtime contract that every Hyperion plugin must honor.
pub trait PluginExt: Send + Sync {
    /// Returns the globally unique identifier registering the plugin in
    /// Hyperion metadata files.
    fn uuid(&self) -> Uuid;

    /// Returns the plugin build/version identifier, typically used for upgrade
    /// decisions and diagnostics.
    fn version(&self) -> &Version;

    /// Human-readable name exposed to CLI tools and logging.
    fn name(&self) -> &str;

    /// Longer description explaining the functionality or requirements of the
    /// plugin.
    fn description(&self) -> &str;

    /// Provide a handle to the plugin's instance context. This is always called
    /// before [`PluginExt::initialize`].
    fn attach_to(&mut self, instance: Weak<InstanceContext>);

    /// Initializes the plugin for a particular [`InstanceContext`]. This is called
    /// once per instance after loading. [`PluginExt`] is always instantiated only once
    /// per process, so any per-instance state must be set up here.
    fn initialize(&self) -> HyResult<()>;

    fn teardown(self);
}

/// Compile-time helpers that let the host instantiate plugins without knowing
/// concrete types.
pub trait PluginExtStatic: PluginExt {
    /// UUID baked into the binary. Must match the value stored in the metadata
    /// TOML file.
    const UUID: Uuid;

    /// Constructs a fresh plugin instance. Implementations should keep
    /// allocation lightweight because this is called on every load.
    fn new(ext: &mut ExtList) -> Self;
}

/// Wrapper around a dynamically loaded plugin extension.
///
/// Prevents the library from being unloaded while the extension is in use by
/// keeping a reference-counted handle alongside the boxed trait object.
pub struct PluginExtWrapper {
    ext: Box<dyn PluginExt>,
    /// SAFETY: `libloading::Library` must outlive any vtables referenced by
    /// `ext`. Storing the `Arc<Library>` *after* `ext` guarantees the drop order
    /// (Rust drops fields top-to-bottom), so the shared object stays loaded
    /// until after the plugin has been torn down. Reordering or removing this
    /// field can trigger use-after-unload UB.
    ///
    /// DO NOT CHANGE THE ORDER OF FIELDS OR DROP GUARANTEES!
    _lib: Arc<libloading::Library>,
}

impl Deref for PluginExtWrapper {
    type Target = dyn PluginExt;

    fn deref(&self) -> &Self::Target {
        &*self.ext
    }
}

impl DerefMut for PluginExtWrapper {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut *self.ext
    }
}

/// Global internal table referencing weak pointers to loaded libraries
/// to prevent redundant loads.
static PLUGIN_LIBRARY_TABLE: RwLock<BTreeMap<PathBuf, Weak<Library>>> =
    RwLock::new(BTreeMap::new());
/// Global mutex used to serialize dynamic library loading operations.
pub static GLOBAL_LD_LIB_LOCK: Mutex<()> = Mutex::new(());

/// SAFETY: dlloading operations are not thread-safe on all platforms. On certain platforms,
/// loading the libraries is not thread-safe if used in conjunction with `DllSetSearchPath` or
/// `LD_LIBRARY_PATH` manipulations. To ensure safety, we use a global mutex
/// [`GLOBAL_LD_LIB_LOCK`] to serialize library loading operations and prevent such issues.
pub unsafe fn load_so_lib(path: &Path) -> HyResult<Arc<Library>> {
    // Convert path to absolute path
    let abs_path = std::fs::canonicalize(path).map_err(|e| HyError::IoError(e))?;

    // Check the global table for an existing load
    {
        let table = PLUGIN_LIBRARY_TABLE.read();
        if let Some(lib) = table.get(&abs_path) {
            if let Some(lib) = lib.upgrade() {
                return Ok(lib);
            }
        }
    }

    // Load the dynamic library
    unsafe {
        let lock = GLOBAL_LD_LIB_LOCK.lock();
        let library = Library::new(&abs_path).map_err(|e| HyError::ExtensionLoadError {
            source: e,
            file: abs_path.to_string_lossy().to_string(),
            name: String::new(),
        })?;

        // Insert into the global table
        let arc_lib = Arc::new(library);
        let mut table = PLUGIN_LIBRARY_TABLE.write();
        table.insert(abs_path.clone(), Arc::downgrade(&arc_lib));
        drop(table);

        // Release the lock
        drop(lock);

        // Return the loaded library
        Ok(arc_lib)
    }
}

/// Loads and instantiates a plugin by name.
///
/// The function searches the supplied [`HyperionMetaInfo`] for a matching name,
/// dlopens the corresponding library, validates compatibility via the exported
/// version requirement, and finally instantiates the plugin via the loader
/// symbol. Any failure along the way is surfaced as [`HyError`].
///
/// SAFETY: Similar to [`_get_plugin_from_path`]
pub unsafe fn load_plugin_by_name(
    meta_info: &HyperionMetaInfo,
    name: &str,
    library_version: Version,
    ext: &mut ExtList,
) -> HyResult<PluginExtWrapper> {
    // Find the extension meta info by UUID
    let ext_info = meta_info
        .ext
        .iter()
        .find(|ext| ext.name == name)
        .ok_or(HyError::ExtensionNotFound(name.to_string()))?;

    // Load the dynamic library
    unsafe {
        let library = load_so_lib(Path::new(&ext_info.path))?;

        // Get the compatibility check function
        let compat_check_fn: libloading::Symbol<ExtCompatibilityCheckFn> = library
            .get(EXT_COMPATIBILITY_CHECK_FN_NAME.as_bytes())
            .map_err(|e| HyError::ExtensionLoadError {
                source: e,
                file: ext_info.path.clone(),
                name: ext_info.name.clone(),
            })?;

        // Check compatibility
        let compat_req = compat_check_fn();
        if !compat_req.matches(&library_version) {
            return Err(HyError::CompatibilityCheckFailed {
                file: ext_info.path.clone(),
                name: ext_info.name.clone(),
                version: library_version,
                req: compat_req,
            });
        }

        // Get the loader function
        let loader_fn: libloading::Symbol<ExtLoaderFn> = library
            .get(EXT_LOADER_FN_NAME.as_bytes())
            .map_err(|e| HyError::ExtensionLoadError {
                source: e,
                file: ext_info.path.clone(),
                name: ext_info.name.clone(),
            })?;

        // Load the extension
        let ext = loader_fn(ext_info.uuid, ext)?;
        Ok(PluginExtWrapper { ext, _lib: library })
    }
}
