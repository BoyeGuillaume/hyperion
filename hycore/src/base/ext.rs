//! Runtime primitives for loading Hyperion plugins from shared libraries.
//!
//! This module ties together the metadata recorded in `HyperionMetaInfo`, the
//! exported symbols generated by `define_plugin_loader!` and
//! `define_plugin_compatibility!`, and the runtime abstractions (`PluginExt`,
//! `PluginExtStatic`, `PluginExtWrapper`) that host applications use after the
//! library is loaded. See `docs/PluginSystem.md` for the broader integration
//! guide.

use std::{
    collections::BTreeMap,
    ops::{Deref, DerefMut},
    path::PathBuf,
    sync::{Arc, Weak},
};

use downcast_rs::{DowncastSync, impl_downcast};
use libloading::Library;
use parking_lot::{Mutex, RwLock};
use semver::{Version, VersionReq};
use uuid::Uuid;

use crate::{
    base::{
        InstanceContext,
        meta::{ExtMetaInfo, HyperionMetaInfo},
    },
    magic::{
        EXT_COMPATIBILITY_CHECK_FN_NAME, EXT_ENTRYPOINT_FN_NAME, EXT_LOADER_FN_NAME,
        EXT_TEARDOWN_FN_NAME,
    },
    utils::{
        conf::{ExtList, PyOpaqueObjectLoader},
        error::{HyError, HyResult},
    },
};

pub struct LibraryBuilderPtr {
    pub opaque_object_loader: Option<&'static RwLock<BTreeMap<String, PyOpaqueObjectLoader>>>,
}

impl LibraryBuilderPtr {
    fn create() -> Self {
        let opaque_object_loader = {
            #[cfg(feature = "pyo3")]
            {
                Some(&crate::utils::conf::PY_OPAQUE_OBJECT_LOADERS)
            }
            #[cfg(not(feature = "pyo3"))]
            {
                None
            }
        };

        LibraryBuilderPtr {
            opaque_object_loader,
        }
    }
}

/// Function signature that plugin crates must expose under
/// [`EXT_LOADER_FN_NAME`]. The host passes the UUID declared in the metadata and
/// expects back an instantiated [`PluginExt`].
pub type ExtLoaderFn = unsafe fn(Uuid, &mut ExtList) -> HyResult<Box<dyn PluginExt>>;

/// Function signature that plugin crates must expose under
/// [`EXT_COMPATIBILITY_CHECK_FN_NAME`]. The function returns the version
/// requirement describing which Hyperion hosts the plugin supports.
pub type ExtCompatibilityCheckFn = unsafe fn() -> VersionReq;

/// Type alias for the extension entry-point function.
pub type ExtEntrypointFn = unsafe fn(LibraryBuilderPtr);

/// Type alias for the extension teardown function.
pub type ExtTeardownFn = unsafe fn(LibraryBuilderPtr);

/// Generates the fixed-name compatibility function that Hyperion probes for
/// after loading the shared object.
///
/// The macro parses the provided string literal as a `semver::VersionReq` and
/// emits `__hyext_fn_compatibility_check`, which is later matched by
/// [`load_plugin_by_name`]. Failures while parsing the literal panic at compile
/// time, so malformed requirements are caught early.
#[macro_export]
macro_rules! define_plugin {
    (
        $compat:literal,
        entry => $entry_fn:path,
        teardown => $teardown_fn:path,
        plugins => [ $( $plugin_ty:ty ),+ $(,)? ] $(,)?
    ) => {
        #[unsafe(no_mangle)]
        pub fn __hyext_fn_compatibility_check() -> semver::VersionReq {
            semver::VersionReq::parse($compat).unwrap()
        }

        #[unsafe(no_mangle)]
        pub fn __hyext_fn_entrypoint(library_builder_ptr: hycore::base::ext::LibraryBuilderPtr) {
            $entry_fn(library_builder_ptr)
        }

        #[unsafe(no_mangle)]
        pub fn __hyext_fn_teardown(library_builder_ptr: hycore::base::ext::LibraryBuilderPtr) {
            $teardown_fn(library_builder_ptr)
        }

        #[unsafe(no_mangle)]
        pub unsafe fn __hyext_fn_loader(uuid: uuid::Uuid, ext: &mut hycore::utils::conf::ExtList) -> hycore::utils::error::HyResult<Box<dyn hycore::base::ext::PluginExt>> {
            match uuid {
                $( <$plugin_ty as hycore::base::ext::PluginExtStatic>::UUID => {
                    let plugin = <$plugin_ty as hycore::base::ext::PluginExtStatic>::new(ext);
                    assert_eq!(plugin.uuid(), <$plugin_ty as hycore::base::ext::PluginExtStatic>::UUID, "Plugin UUID does not match the expected UUID");
                    return Ok(Box::new(plugin));
                }, )+
                _ => {
                    Err(hycore::utils::error::HyError::ExtensionNotFound(uuid.to_string()))
                },
            }
        }
    };
}

/// Runtime contract that every Hyperion plugin must honor.
pub trait PluginExt: DowncastSync {
    /// Returns the globally unique identifier registering the plugin in
    /// Hyperion metadata files.
    fn uuid(&self) -> Uuid;

    /// Returns the plugin build/version identifier, typically used for upgrade
    /// decisions and diagnostics.
    fn version(&self) -> &Version;

    /// Human-readable name exposed to CLI tools and logging.
    fn name(&self) -> &str;

    /// Longer description explaining the functionality or requirements of the
    /// plugin.
    fn description(&self) -> &str;

    /// Provide a handle to the plugin's instance context. This is always called
    /// before [`PluginExt::initialize`].
    fn attach_to(&mut self, instance: Weak<InstanceContext>);

    /// Initializes the plugin for a particular [`InstanceContext`]. This is called
    /// once per instance after loading. [`PluginExt`] is always instantiated only once
    /// per process, so any per-instance state must be set up here.
    fn initialize(&self) -> HyResult<()>;

    /// Tears down the plugin, releasing any resources held. This is called
    /// once per instance when the instance is being destroyed.
    fn teardown(&mut self);
}
impl_downcast!(sync PluginExt);

/// Compile-time helpers that let the host instantiate plugins without knowing
/// concrete types.
pub trait PluginExtStatic: PluginExt {
    /// UUID baked into the binary. Must match the value stored in the metadata
    /// TOML file.
    const UUID: Uuid;

    /// Constructs a fresh plugin instance. Implementations should keep
    /// allocation lightweight because this is called on every load.
    fn new(ext: &mut ExtList) -> Self;
}

/// Wrapper around a dynamically loaded plugin extension.
///
/// Prevents the library from being unloaded while the extension is in use by
/// keeping a reference-counted handle alongside the boxed trait object.
pub struct PluginExtWrapper {
    ext: Box<dyn PluginExt>,
    /// SAFETY: `libloading::Library` must outlive any vtables referenced by
    /// `ext`. Storing the `Arc<Library>` *after* `ext` guarantees the drop order
    /// (Rust drops fields top-to-bottom), so the shared object stays loaded
    /// until after the plugin has been torn down. Reordering or removing this
    /// field can trigger use-after-unload UB.
    ///
    /// DO NOT CHANGE THE ORDER OF FIELDS OR DROP GUARANTEES!
    _lib: Arc<LibraryWrapper>,
}

impl Deref for PluginExtWrapper {
    type Target = dyn PluginExt;

    fn deref(&self) -> &Self::Target {
        &*self.ext
    }
}

impl DerefMut for PluginExtWrapper {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut *self.ext
    }
}

/// Wrapper around [`libloading::Library`] that calls the teardown function
/// when dropped.
pub struct LibraryWrapper(pub Library);

impl Drop for LibraryWrapper {
    fn drop(&mut self) {
        unsafe {
            // Call the teardown function if it exists
            let teardown_fn: libloading::Symbol<ExtTeardownFn> =
                match self.0.get(EXT_TEARDOWN_FN_NAME.as_bytes()) {
                    Ok(symbol) => symbol,
                    Err(_) => return, // No teardown function, nothing to do
                };
            teardown_fn(LibraryBuilderPtr::create());
        }
    }
}

/// Global internal table referencing weak pointers to loaded libraries
/// to prevent redundant loads.
static PLUGIN_LIBRARY_TABLE: RwLock<BTreeMap<PathBuf, Weak<LibraryWrapper>>> =
    RwLock::new(BTreeMap::new());
/// Global mutex used to serialize dynamic library loading operations.
pub static GLOBAL_LD_LIB_LOCK: Mutex<()> = Mutex::new(());

/// SAFETY: dlloading operations are not thread-safe on all platforms. On certain platforms,
/// loading the libraries is not thread-safe if used in conjunction with `DllSetSearchPath` or
/// `LD_LIBRARY_PATH` manipulations. To ensure safety, we use a global mutex
/// [`GLOBAL_LD_LIB_LOCK`] to serialize library loading operations and prevent such issues.
pub unsafe fn load_so_lib(ext_info: &ExtMetaInfo) -> HyResult<Arc<LibraryWrapper>> {
    // Convert path to absolute path
    let abs_path = std::fs::canonicalize(&ext_info.path).map_err(|e| HyError::IoError(e))?;

    // Check the global table for an existing load
    {
        let table = PLUGIN_LIBRARY_TABLE.read();
        if let Some(lib) = table.get(&abs_path) {
            if let Some(lib) = lib.upgrade() {
                return Ok(lib);
            }
        }
    }

    // Load the dynamic library
    let library = unsafe {
        let lock = GLOBAL_LD_LIB_LOCK.lock();
        let library = Library::new(&abs_path).map_err(|e| HyError::ExtensionLoadError {
            source: e,
            file: abs_path.to_string_lossy().to_string(),
            name: ext_info.name.clone(),
        })?;

        // Insert into the global table
        let arc_lib = Arc::new(LibraryWrapper(library));

        // Call to the entrypoint function to ensure proper initialization
        let entrypoint_fn: libloading::Symbol<ExtEntrypointFn> = arc_lib
            .0
            .get(EXT_ENTRYPOINT_FN_NAME.as_bytes())
            .map_err(|_| HyError::ExtensionLoadErrorSymbolNotFound {
                file: abs_path.to_string_lossy().to_string(),
                name: ext_info.name.clone(),
                symbol: EXT_ENTRYPOINT_FN_NAME,
            })?;
        entrypoint_fn(LibraryBuilderPtr::create());

        // Check version compatibility of the loaded library
        let compat_check_fn: libloading::Symbol<ExtCompatibilityCheckFn> = arc_lib
            .0
            .get(EXT_COMPATIBILITY_CHECK_FN_NAME.as_bytes())
            .map_err(|_| HyError::ExtensionLoadErrorSymbolNotFound {
                file: abs_path.to_string_lossy().to_string(),
                name: ext_info.name.clone(),
                symbol: EXT_COMPATIBILITY_CHECK_FN_NAME,
            })?;

        // Check compatibility
        let compat_req = compat_check_fn();
        let library_version = semver::Version::parse(env!("CARGO_PKG_VERSION")).unwrap();
        if !compat_req.matches(&library_version) {
            return Err(HyError::CompatibilityCheckFailed {
                file: ext_info.path.clone(),
                name: ext_info.name.clone(),
                version: library_version,
                req: compat_req,
            });
        }

        let mut table = PLUGIN_LIBRARY_TABLE.write();
        table.insert(abs_path.clone(), Arc::downgrade(&arc_lib));
        drop(table);

        // Release the lock
        drop(lock);

        // Return the loaded library
        arc_lib
    };

    Ok(library)
}

/// Guard for preloaded plugins, this is because we need to preload shared libraries
/// prior to decoding extensions (when using Python).
pub struct PluginPreloadGuard {
    _libraries: Vec<Arc<LibraryWrapper>>,
}

pub unsafe fn preload_plugins(ext_names: Vec<String>) -> HyResult<PluginPreloadGuard> {
    // Open the metadata containing build info.
    let meta_path = HyperionMetaInfo::default_path();
    let meta_info = HyperionMetaInfo::load_from_toml(&meta_path)?;

    let mut _libraries = Vec::new();
    for ext_name in ext_names {
        let ext_info = meta_info
            .ext
            .iter()
            .find(|x| x.name == ext_name)
            .ok_or_else(|| {
                HyError::ExtensionNotFound(format!(
                    "Extension '{}' not found in metadata.",
                    ext_name
                ))
            })?;

        let library = unsafe { load_so_lib(ext_info)? };
        _libraries.push(library);
    }

    Ok(PluginPreloadGuard { _libraries })
}

/// Loads and instantiates a plugin by name.
///
/// The function searches the supplied [`HyperionMetaInfo`] for a matching name,
/// dlopens the corresponding library, validates compatibility via the exported
/// version requirement, and finally instantiates the plugin via the loader
/// symbol. Any failure along the way is surfaced as [`HyError`].
///
/// SAFETY: Similar to [`_get_plugin_from_path`]
pub unsafe fn load_plugin_by_name(
    meta_info: &HyperionMetaInfo,
    name: &str,
    ext: &mut ExtList,
) -> HyResult<PluginExtWrapper> {
    // Find the extension meta info by UUID
    let ext_info = meta_info
        .ext
        .iter()
        .find(|ext| ext.name == name)
        .ok_or(HyError::ExtensionNotFound(name.to_string()))?;

    // Load the dynamic library
    unsafe {
        let library = load_so_lib(ext_info)?;

        // Get the loader function
        let loader_fn: libloading::Symbol<ExtLoaderFn> = library
            .0
            .get(EXT_LOADER_FN_NAME.as_bytes())
            .map_err(|_| HyError::ExtensionLoadErrorSymbolNotFound {
                file: ext_info.path.clone(),
                name: ext_info.name.clone(),
                symbol: EXT_LOADER_FN_NAME,
            })?;

        // Load the extension
        let ext = loader_fn(ext_info.uuid, ext)?;
        Ok(PluginExtWrapper { ext, _lib: library })
    }
}
