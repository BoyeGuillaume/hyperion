//! Runtime primitives for loading Hyperion plugins from shared libraries.
//!
//! This module ties together the metadata recorded in `HyperionMetaInfo`, the
//! exported symbols generated by `define_plugin_loader!` and
//! `define_plugin_compatibility!`, and the runtime abstractions (`PluginExt`,
//! `PluginExtStatic`, `PluginExtWrapper`) that host applications use after the
//! library is loaded. See `docs/PluginSystem.md` for the broader integration
//! guide.

use std::{ops::Deref, sync::Arc};

use libloading::Library;
use semver::{Version, VersionReq};
use uuid::Uuid;

use crate::{
    base::meta::HyperionMetaInfo,
    magic::{EXT_COMPATIBILITY_CHECK_FN_NAME, EXT_LOADER_FN_NAME},
    utils::error::{HyError, HyResult},
};

/// Function signature that plugin crates must expose under
/// [`EXT_LOADER_FN_NAME`]. The host passes the UUID declared in the metadata and
/// expects back an instantiated [`PluginExt`].
pub type ExtLoaderFn = unsafe fn(Uuid) -> HyResult<Box<dyn PluginExt>>;

/// Function signature that plugin crates must expose under
/// [`EXT_COMPATIBILITY_CHECK_FN_NAME`]. The function returns the version
/// requirement describing which Hyperion hosts the plugin supports.
pub type ExtCompatibilityCheckFn = unsafe fn() -> VersionReq;

/// Generates the fixed-name compatibility function that Hyperion probes for
/// after loading the shared object.
///
/// The macro parses the provided string literal as a `semver::VersionReq` and
/// emits `__hyext_fn_compatibility_check`, which is later matched by
/// [`load_plugin_by_name`]. Failures while parsing the literal panic at compile
/// time, so malformed requirements are caught early.
#[macro_export]
macro_rules! define_plugin_compatibility {
    (
        $compat:literal
    ) => {
        #[unsafe(no_mangle)]
        pub fn __hyext_fn_compatibility_check() -> semver::VersionReq {
            semver::VersionReq::parse($compat).unwrap()
        }
    };
}

/// Generates the entry-point loader function used to instantiate plugins.
///
/// The macro accepts one or more concrete types implementing
/// [`PluginExtStatic`]. At runtime Hyperion passes the UUID read from metadata
/// and expects the loader to return the matching plugin instance. Unknown UUIDs
/// translate into [`HyError::ExtensionNotFound`].
#[macro_export]
macro_rules! define_plugin_loader {
    (
        $( $plugin_ty:ty ),+
        $(,)?
    ) => {
        #[unsafe(no_mangle)]
        pub unsafe fn __hyext_fn_loader(uuid: uuid::Uuid) -> hycore::utils::error::HyResult<Box<dyn hycore::base::ext::PluginExt>> {
            match uuid {
                $(
                    <$plugin_ty as hycore::base::ext::PluginExtStatic>::UUID => {
                        let plugin = <$plugin_ty as hycore::base::ext::PluginExtStatic>::new();
                        assert_eq!(plugin.uuid(), <$plugin_ty as hycore::base::ext::PluginExtStatic>::UUID, "Plugin UUID does not match the expected UUID");
                        return Ok(Box::new(plugin));
                    },
                )+
                _ => {
                    Err(hycore::utils::error::HyError::ExtensionNotFound(uuid.to_string()))
                },
            }
        }
    };
}

/// Runtime contract that every Hyperion plugin must honor.
pub trait PluginExt: Send + Sync {
    /// Returns the globally unique identifier registering the plugin in
    /// Hyperion metadata files.
    fn uuid(&self) -> Uuid;

    /// Returns the plugin build/version identifier, typically used for upgrade
    /// decisions and diagnostics.
    fn version(&self) -> &Version;

    /// Human-readable name exposed to CLI tools and logging.
    fn name(&self) -> &str;

    /// Longer description explaining the functionality or requirements of the
    /// plugin.
    fn description(&self) -> &str;
}

/// Compile-time helpers that let the host instantiate plugins without knowing
/// concrete types.
pub trait PluginExtStatic: PluginExt {
    /// UUID baked into the binary. Must match the value stored in the metadata
    /// TOML file.
    const UUID: Uuid;

    /// Constructs a fresh plugin instance. Implementations should keep
    /// allocation lightweight because this is called on every load.
    fn new() -> Self;
}

/// Wrapper around a dynamically loaded plugin extension.
///
/// Prevents the library from being unloaded while the extension is in use by
/// keeping a reference-counted handle alongside the boxed trait object.
pub struct PluginExtWrapper {
    ext: Box<dyn PluginExt>,
    /// SAFETY: `libloading::Library` must outlive any vtables referenced by
    /// `ext`. Storing the `Arc<Library>` *after* `ext` guarantees the drop order
    /// (Rust drops fields top-to-bottom), so the shared object stays loaded
    /// until after the plugin has been torn down. Reordering or removing this
    /// field can trigger use-after-unload UB.
    ///
    /// DO NOT CHANGE THE ORDER OF FIELDS OR DROP GUARANTEES!
    _lib: Arc<libloading::Library>,
}

impl Deref for PluginExtWrapper {
    type Target = dyn PluginExt;

    fn deref(&self) -> &Self::Target {
        &*self.ext
    }
}

/// Loads and instantiates a plugin by name.
///
/// The function searches the supplied [`HyperionMetaInfo`] for a matching name,
/// dlopens the corresponding library, validates compatibility via the exported
/// version requirement, and finally instantiates the plugin via the loader
/// symbol. Any failure along the way is surfaced as [`HyError`].
pub fn load_plugin_by_name(
    meta_info: &HyperionMetaInfo,
    name: &str,
    library_version: Version,
) -> HyResult<PluginExtWrapper> {
    // Find the extension meta info by UUID
    let ext_info = meta_info
        .ext
        .iter()
        .find(|ext| ext.name == name)
        .ok_or(HyError::ExtensionNotFound(name.to_string()))?;

    // Load the dynamic library
    unsafe {
        let library = Library::new(&ext_info.path).map_err(|e| HyError::ExtensionLoadError {
            source: e,
            file: ext_info.path.clone(),
            name: ext_info.name.clone(),
        })?;

        // Get the compatibility check function
        let compat_check_fn: libloading::Symbol<ExtCompatibilityCheckFn> = library
            .get(EXT_COMPATIBILITY_CHECK_FN_NAME.as_bytes())
            .map_err(|e| HyError::ExtensionLoadError {
                source: e,
                file: ext_info.path.clone(),
                name: ext_info.name.clone(),
            })?;

        // Check compatibility
        let compat_req = compat_check_fn();
        if !compat_req.matches(&library_version) {
            return Err(HyError::CompatibilityCheckFailed {
                file: ext_info.path.clone(),
                name: ext_info.name.clone(),
                version: library_version,
                req: compat_req,
            });
        }

        // Get the loader function
        let loader_fn: libloading::Symbol<ExtLoaderFn> = library
            .get(EXT_LOADER_FN_NAME.as_bytes())
            .map_err(|e| HyError::ExtensionLoadError {
                source: e,
                file: ext_info.path.clone(),
                name: ext_info.name.clone(),
            })?;

        // Load the extension
        let ext = loader_fn(ext_info.uuid)?;

        Ok(PluginExtWrapper {
            _lib: Arc::new(library),
            ext,
        })
    }
}
