define i32 pow(%a: i32, %n: i32) {
entry:
    %is_null: i1 = icmp.eq %n, i32 0
    branch %is_null, output, loop

loop:
    %current_n: i32 = phi [%n, entry], [%next_n, loop]
    %current_res: i32 = phi [i32 1, entry], [%next_res, loop]
    %next_n: i32 = isub.wrap %current_n, i32 1
    %next_res: i32 = imul.usat %current_res, %a
    %loop.is_null: i32 = icmp.eq %next_n, i32 0
    branch %loop.is_null, output, loop

output:
    %output: i32 = phi [i32 1, entry], [%next_res, loop]
    ret %output
}

define fp32 dot3(%a: <3 x fp32>, %b: <3 x fp32>) {
entry:
    %ax: fp32 = extractvalue %a, i32 0
    %ay: fp32 = extractvalue %a, i32 1
    %az: fp32 = extractvalue %a, i32 2
    %bx: fp32 = extractvalue %b, i32 0
    %by: fp32 = extractvalue %b, i32 1
    %bz: fp32 = extractvalue %b, i32 2
    %m0: fp32 = fmul %ax, %bx
    %m1: fp32 = fmul %ay, %by
    %m2: fp32 = fmul %az, %bz
    %s0: fp32 = fadd %m0, %m1
    %s1: fp32 = fadd %s0, %m2
    ret %s1
}

define fp32 pow_fp32(%x: fp32, %exp: i32) {
entry:
    %exp_is_zero: i1 = icmp.eq %exp, i32 0
    branch %exp_is_zero, pow_zero, pow_loop

pow_zero:
    ret fp32 1.0

pow_loop:
    %acc: fp32 = phi [ fp32 1.0, entry ], [ %acc_next, pow_iter ]
    %e: i32 = phi [ %exp, entry ], [ %e_next, pow_iter ]
    %done: i1 = icmp.eq %e, i32 0
    branch %done, pow_exit, pow_iter

pow_iter:
    %acc_next: fp32 = fmul %acc, %x
    %e_next: i32 = isub.wrap %e, i32 1
    jump pow_loop

pow_exit:
    ret %acc
}

define fp32 sqrt_newton(%x: fp32) {
entry:
    %half_x: fp32 = fmul %x, fp32 0.5
    %guess0: fp32 = fadd %half_x, fp32 1.0
    %reciprocal: fp32 = fdiv %x, %guess0
    %avg: fp32 = fadd %guess0, %reciprocal
    %guess1: fp32 = fmul %avg, fp32 0.5
    %reciprocal2: fp32 = fdiv %x, %guess1
    %avg2: fp32 = fadd %guess1, %reciprocal2
    %guess2: fp32 = fmul %avg2, fp32 0.5
    ret %guess2
}

define fp32 dot_dynamic(%a: { ptr, i32 }, %b: { ptr, i32 }) {
entry:
    %a_data: ptr = extractvalue %a, i32 0
    %a_len: i32 = extractvalue %a, i32 1
    %b_data: ptr = extractvalue %b, i32 0
    %b_len: i32 = extractvalue %b, i32 1
    %same_len: i1 = icmp.eq %a_len, %b_len
    branch %same_len, dot_loop, dot_empty

dot_empty:
    ret fp32 0.0

dot_loop:
    %acc: fp32 = phi [ fp32 0.0, entry ], [ %acc_next, dot_iter ]
    %idx: i32 = phi [ i32 0, entry ], [ %idx_next, dot_iter ]
    %done: i1 = icmp.eq %idx, %a_len
    branch %done, dot_exit, dot_iter

dot_iter:
    %offset_a: ptr = getelementptr %a_data, %idx
    %offset_b: ptr = getelementptr %b_data, %idx
    %aval: fp32 = load %offset_a, align 4
    %bval: fp32 = load %offset_b, align 4
    %prod: fp32 = fmul %aval, %bval
    %acc_next: fp32 = fadd %acc, %prod
    %idx_next: i32 = iadd.wrap %idx, i32 1
    jump dot_loop

dot_exit:
    ret %acc
}

define i32 max_u32(%data: ptr, %len: i32) {
entry:
    %empty: i1 = icmp.eq %len, i32 0
    branch %empty, max_zero, max_init

max_zero:
    trap

max_init:
    %first_ptr: ptr = getelementptr %data, i32 0
    %current: i32 = load %first_ptr
    jump max_loop

max_loop:
    %max: i32 = phi [ %current, max_init ], [ %max_next, max_iter ]
    %idx: i32 = phi [ i32 1, max_init ], [ %idx_next, max_iter ]
    %done: i1 = icmp.eq %idx, %len
    branch %done, max_exit, max_iter

max_iter:
    %ptr_i: ptr = getelementptr %data, %idx
    %value: i32 = load %ptr_i
    %cmp: i1 = icmp.ugt %value, %max
    %max_next: i32 = select %cmp, %value, %max
    %idx_next: i32 = iadd.wrap %idx, i32 1
    jump max_loop

max_exit:
    ret %max
}

define i32 clamp_i32(%x: i32, %lo: i32, %hi: i32) {
entry:
    %lt_lo: i1 = icmp.slt %x, %lo
    %gt_hi: i1 = icmp.sgt %x, %hi
    %lo_or_x: i32 = select %lt_lo, %lo, %x
    %clamped: i32 = select %gt_hi, %hi, %lo_or_x
    ret %clamped
}

define void !example_meta() {
entry:
    %x: i32 = !forall
    %y: i32 = iadd.wrap i32 0, i32 0
    %z: i32 = !analysis.term.reach stop, other
    jump entry
stop:
    ret void
other:
    ret void
}
